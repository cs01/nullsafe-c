
        // Add real-time diagnostics  
        let diagnosticsTimeout;
        function setupDiagnostics() {
            if (!editor) return;
            
            editor.onDidChangeModelContent(() => {
                clearTimeout(diagnosticsTimeout);
                diagnosticsTimeout = setTimeout(() => {
                    updateDiagnostics();
                }, 500);
            });
        }

        async function updateDiagnostics() {
            if (!scriptUrl || isCompiling) return;

            try {
                const code = getEditorValue();
                const result = await compileCode(code, []);
                const diagnostics = parseDiagnostics(result.stderr);
                monaco.editor.setModelMarkers(editor.getModel(), 'clang', diagnostics);
            } catch (error) {
                // Silently fail - diagnostics are non-critical
            }
        }

        function parseDiagnostics(stderr) {
            const markers = [];
            const lines = stderr.split('\n');
            const diagnosticRegex = /^input\.c:(\d+):(\d+):\s+(error|warning|note):\s+(.+)$/;

            for (const line of lines) {
                const match = line.match(diagnosticRegex);
                if (match) {
                    const [, lineNum, colNum, severity, message] = match;
                    markers.push({
                        startLineNumber: parseInt(lineNum),
                        startColumn: parseInt(colNum),
                        endLineNumber: parseInt(lineNum),
                        endColumn: parseInt(colNum) + 1,
                        message: message,
                        severity: severity === 'error' ? monaco.MarkerSeverity.Error
                                : severity === 'warning' ? monaco.MarkerSeverity.Warning
                                : monaco.MarkerSeverity.Info
                    });
                }
            }
            return markers;
        }
